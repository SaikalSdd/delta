%!TEX root = spec.tex

\chapter{Expressions}

\section{Unary expressions}

\begin{grammar}
\nonterminal{prefix-unary-expression} \textrightarrow{} \nonterminal{operator} \nonterminal{operand}\\
\nonterminal{postfix-unary-expression} \textrightarrow{} \nonterminal{operand} \nonterminal{operator}
\end{grammar}

\subsection{Unwrap expression}

\begin{grammar}
\nonterminal{unwrap-expression} \textrightarrow{} \nonterminal{operand} \code{!}
\end{grammar}

The \nonterminal{unwrap-expression} takes an operand of an optional type, and
returns the value wrapped by the optional. If the operand is null, an assertion
error will be triggered, except in unchecked mode, where the compiler may assume
that the operand is never null.

\section{Binary expression}

\begin{grammar}
\nonterminal{binary-expression} \textrightarrow{} \nonterminal{left-hand-side} \nonterminal{binary-operator} \nonterminal{right-hand-side}
\end{grammar}

\subsection{Integer arithmetic expressions}

Arithmetic operations on integers (both signed and unsigned) are checked for
overflow by default. In unchecked builds, integer overflow causes undefined
behavior (for both signed and unsigned operations).

\section{Conditional expression}

\begin{grammar}
\nonterminal{conditional-expression} \textrightarrow{} \nonterminal{condition} \code{?} \nonterminal{then-expression} \code{:} \nonterminal{else-expression}
\end{grammar}

\section{Member access expression}

\begin{grammar}
\nonterminal{member-access-expression} \textrightarrow{} \nonterminal{expression} \code{.} \nonterminal{identifier}
\end{grammar}

\section{Subscript expression}

\begin{grammar}
\nonterminal{subscript-expression} \textrightarrow{} \nonterminal{expression} \code{[} \nonterminal{expression} \code{]}
\end{grammar}

\section{Function call expression}

\begin{grammar}
\nonterminal{call-expression} \textrightarrow{} \nonterminal{expression} \code{(} \nonterminal{argument-list} \code{)}
\end{grammar}

\nonterminal{argument-list} is a comma-separated list of zero or more
\nonterminal{argument-specifiers}:

\begin{grammar}
\nonterminal{argument-specifier} \textrightarrow{} \nonterminal{unnamed-argument} | \nonterminal{named-argument}\\
\nonterminal{unnamed-argument} \textrightarrow{} \nonterminal{expression}\\
\nonterminal{named-argument} \textrightarrow{} \nonterminal{argument-name} \code{:} \nonterminal{expression}
\end{grammar}

\nonterminal{argument-name} is an identifier specifying the name of the
parameter the argument \nonterminal{expression} is being assigned to.

\section{Range expression}

\begin{grammar}
\nonterminal{exclusive-range-expression} \textrightarrow{} \nonterminal{lower-bound} \code{..} \nonterminal{upper-bound}\\
\nonterminal{inclusive-range-expression} \textrightarrow{} \nonterminal{lower-bound} \code{...} \nonterminal{upper-bound}
\end{grammar}

\section{Closure expression}

\begin{grammar}
\nonterminal{closure-expression} \textrightarrow{} \code{(} \nonterminal{parameter-list} \code{)} \code{->} \nonterminal{expression}\\
\nonterminal{closure-expression} \textrightarrow{} \code{(} \nonterminal{parameter-list} \code{)} \code{->} \nonterminal{block}
\end{grammar}

Specifying the type for parameters in a closure \nonterminal{parameter-list} is
optional. Omitting the type (and the corresponding colon) causes the type for
that parameter to be inferred from the context.

If the closure \nonterminal{parameter-list} only contains one parameter, the
enclosing parentheses may be omitted.
