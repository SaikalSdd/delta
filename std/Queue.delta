/// First-in-first-out data structure
struct Queue<T> {
    var head: mutable Node<T>*?;
    var tail: mutable Node<T>*?;
    var size: int;

    /// Initialize an empty Queue
    init() {
        head = null;
        tail = null;
        size = 0;
    }

    deinit() {
        while (!isEmpty()) {
            var next = head!.next;
            deallocate(head!);
            head = next;
        }
    }

    /// Add to the back of the queue
    mutating def push(value: T) {
        var newNode = allocate(Node(value));

        if (isEmpty()) {
            head = newNode;
            tail = newNode;
        } else {
            tail!.next = newNode;
            tail = newNode;
        }

        size++;
    }

    /// Retrieve and remove head of the queue
    mutating def pop(): T {
        var value = head!.value;
        var next = head!.next;
        deallocate(head!);
        head = next;

        if (head == null) {
            tail = null;
        }

        size--;
        return value;
    }

    /// Access element in the front of the queue
    def first(): T* {
        return head!.value;
    }

    /// Returns the number of elements in the queue
    def size(): int {
        return size;
    }

    /// Check if queue is empty
    def isEmpty(): bool {
        return head == null;
    }
}

struct Node<T> {
    var next: mutable Node<T>*?;
    var value: T;

    init(val: T) {
        this.value = val;
        this.next = null;
    }
}
